<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Lumen</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
<li><a href="#Tables">Tables</a></li>
<li><a href="#Fields">Fields</a></li>
<li><a href="#Data_structures">Data structures</a></li>
</ul>


<h2>Modules</h2>
<ul>
  <li><a href="../modules/catalog.html">catalog</a></li>
  <li><a href="../modules/debug.html">debug</a></li>
  <li><a href="../modules/http-server.html">http-server</a></li>
  <li><a href="../modules/mutex.html">mutex</a></li>
  <li><a href="../modules/pipes.html">pipes</a></li>
  <li><a href="../modules/proxy.html">proxy</a></li>
  <li><strong>sched</strong></li>
  <li><a href="../modules/selector.html">selector</a></li>
  <li><a href="../modules/shell.html">shell</a></li>
  <li><a href="../modules/stream.html">stream</a></li>
</ul>
<h2>Topics</h2>
<ul>
  <li><a href="../topics/README.md.html">README.md</a></li>
</ul>
<h2>Examples</h2>
<ul>
  <li><a href="../examples/test-buff.lua.html">test-buff.lua</a></li>
  <li><a href="../examples/test-http-server.lua.html">test-http-server.lua</a></li>
  <li><a href="../examples/test-mutex.lua.html">test-mutex.lua</a></li>
  <li><a href="../examples/test-pipe.lua.html">test-pipe.lua</a></li>
  <li><a href="../examples/test-selector.lua.html">test-selector.lua</a></li>
  <li><a href="../examples/test-stress.lua.html">test-stress.lua</a></li>
  <li><a href="../examples/test-wait.lua.html">test-wait.lua</a></li>
  <li><a href="../examples/test.lua.html">test.lua</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>sched</code></h1>

<p>Lumen cooperative scheduler.</p>
<p> Lumen (Lua Multitasking Environment) is a simple environment 
 for coroutine based multitasking. Consists of a signal scheduler, 
 and that's it.
 Functions that receive a task or wait descriptors can be invoked as methods
 of the corresponing events. For example, sched.kill(task) can be invoked as 
 task:kill()</p>
    <h3>Usage:</h3>
    <ul>
        <pre class="example">local sched = require 'sched'
sched.sigrun({emitter='*', events={'a signal'}}, print)
local task=sched.run(function()
   sched.signal('a signal', 'data')
   sched.sleep(1)
end)</pre>
    </ul>

<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#new_task">new_task&nbsp;(f)</a></td>
	<td class="summary">Create a task.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#new_sigrun_task">new_sigrun_task&nbsp;(waitd, f)</a></td>
	<td class="summary">Create a task that listens for a signal.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#new_sigrunonce_task">new_sigrunonce_task&nbsp;(waitd, f)</a></td>
	<td class="summary">Create a task that listens for a signal, once.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#run">run&nbsp;(task, ...)</a></td>
	<td class="summary">Run a task.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#sigrun">sigrun&nbsp;(waitd, f, attached)</a></td>
	<td class="summary">Create and run a task that listens for a signal.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#sigrunonce">sigrunonce&nbsp;(waitd, f, attached)</a></td>
	<td class="summary">Create and run a task that listens for a signal, once.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#attach">attach&nbsp;(taskd, taskd_child)</a></td>
	<td class="summary">Attach a task to another.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#set_as_attached">set_as_attached&nbsp;(taskd)</a></td>
	<td class="summary">Set a task as attached to the creator task.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#kill">kill&nbsp;(taskd)</a></td>
	<td class="summary">Finishes a task.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#signal">signal&nbsp;(event, ...)</a></td>
	<td class="summary">Emit a signal.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#new_waitd">new_waitd&nbsp;(waitd_table)</a></td>
	<td class="summary">Create a Wait Descriptor.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#new_multiwaitd">new_multiwaitd&nbsp;(...)</a></td>
	<td class="summary">Create a Multiwait Descriptor.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wait">wait&nbsp;(waitd)</a></td>
	<td class="summary">Wait for a signal.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#sleep">sleep&nbsp;(timeout)</a></td>
	<td class="summary">Sleeps the task for t time units.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#yield">yield&nbsp;()</a></td>
	<td class="summary">Yields the execution of a task, as in cooperative multitasking.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#set_pause">set_pause&nbsp;(taskd, pause)</a></td>
	<td class="summary">Pause a task.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#idle">idle&nbsp;(t)</a></td>
	<td class="summary">Idle function.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#get_time">get_time&nbsp;()</a></td>
	<td class="summary">Function used by the scheduler to get current time.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#step">step&nbsp;()</a></td>
	<td class="summary">Runs a single step of the scheduler.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#go">go&nbsp;()</a></td>
	<td class="summary">Starts the scheduler.</td>
	</tr>
</table>
<h2><a href="#Tables">Tables</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#tasks">tasks</a></td>
	<td class="summary">Tasks in scheduler.</td>
	</tr>
</table>
<h2><a href="#Fields">Fields</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#waitds">waitds</a></td>
	<td class="summary">Wait descriptors in scheduler.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#EVENT_DIE">EVENT_DIE</a></td>
	<td class="summary">Task dying event.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#to_clean_up">to_clean_up</a></td>
	<td class="summary">Control memory collection.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#running_task">running_task</a></td>
	<td class="summary">Currently running task.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#debug">debug</a></td>
	<td class="summary">Debugging module.</td>
	</tr>
</table>
<h2><a href="#Data_structures">Data structures</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#waitd">waitd</a></td>
	<td class="summary">Wait descriptor.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#taskd">taskd</a></td>
	<td class="summary">Task descriptor.</td>
	</tr>
</table>

<br/>
<br/>


    <h2><a name="Functions"></a>Functions</h2>
    
    <dl class="function">
    <dt>
    <a name = "new_task"></a>
    <strong>new_task&nbsp;(f)</strong>
    </dt>
    <dd>
    Create a task. 
 The task is created in paused mode. To run the created task,
 use <a href="../modules/sched.html#run">run</a> or <a href="../modules/sched.html#set_pause">set_pause</a>.
 The task will emit a <em>sched.EVENT_DIE, true, params...</em>
 signal upon normal finalization, were params are the returns of f.
 If there is a error, the task will emit a <em>sched.EVENT_DIE, false, err</em> were
 err is the error message.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>f</em></code>:  function for the task</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        task in the scheduler (see <a href="../modules/sched.html#taskd">taskd</a>).
    </ol>


</dd>
    <dt>
    <a name = "new_sigrun_task"></a>
    <strong>new_sigrun_task&nbsp;(waitd, f)</strong>
    </dt>
    <dd>
    Create a task that listens for a signal. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>waitd</em></code>:  a Wait Descriptor for the signal (see <a href="../modules/sched.html#waitd">waitd</a>)</li>
       <li><code><em>f</em></code>:  function to be called when the signal appears. The signal
 is passed to f as parameter.The signal will be provided as 
 <em>emitter, event, parameters</em>, just as the result of a <a href="../modules/sched.html#wait">wait</a></li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        task in the scheduler (see <a href="../modules/sched.html#taskd">taskd</a>).
    </ol>


</dd>
    <dt>
    <a name = "new_sigrunonce_task"></a>
    <strong>new_sigrunonce_task&nbsp;(waitd, f)</strong>
    </dt>
    <dd>
    Create a task that listens for a signal, once. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>waitd</em></code>:  a Wait Descriptor for the signal (see <a href="../modules/sched.html#waitd">waitd</a>)</li>
       <li><code><em>f</em></code>:  function to be called when the signal appears. The signal
 is passed to f as parameter. The signal will be provided as 
 <em>emitter, event, parameters</em>, just as the result of a <a href="../modules/sched.html#wait">wait</a></li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        task in the scheduler (see <a href="../modules/sched.html#taskd">taskd</a>).
    </ol>


</dd>
    <dt>
    <a name = "run"></a>
    <strong>run&nbsp;(task, ...)</strong>
    </dt>
    <dd>
    Run a task. 
 Can be provided either a <a href="../modules/sched.html#taskd">taskd</a> or a function with optional parameters.
 If provided a taskd, will run it. If provided a function, will use <a href="../modules/sched.html#new_task">new_task</a>
 to create a task first.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>task</em></code>:  wither a <a href="../modules/sched.html#taskd">taskd</a> or function for the task.</li>
       <li><code><em>...</em></code>:  parameters passed to the task upon first run.</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        a task in the scheduler (see <a href="../modules/sched.html#taskd">taskd</a>).
    </ol>


</dd>
    <dt>
    <a name = "sigrun"></a>
    <strong>sigrun&nbsp;(waitd, f, attached)</strong>
    </dt>
    <dd>
    Create and run a task that listens for a signal. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>waitd</em></code>:  a Wait Descriptor for the signal (see <a href="../modules/sched.html#waitd">waitd</a>)</li>
       <li><code><em>f</em></code>:  function to be called when the signal appears. The signal
 is passed to f as parameter.The signal will be provided as 
 <em>emitter, event, parameters</em>, just as the result of a <a href="../modules/sched.html#wait">wait</a></li>
       <li><code><em>attached</em></code>:  if true, the new task will run in attached more</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        task in the scheduler (see <a href="../modules/sched.html#taskd">taskd</a>).
    </ol>


</dd>
    <dt>
    <a name = "sigrunonce"></a>
    <strong>sigrunonce&nbsp;(waitd, f, attached)</strong>
    </dt>
    <dd>
    Create and run a task that listens for a signal, once. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>waitd</em></code>:  a Wait Descriptor for the signal (see <a href="../modules/sched.html#waitd">waitd</a>)</li>
       <li><code><em>f</em></code>:  function to be called when the signal appears. The signal
 is passed to f as parameter. The signal will be provided as 
 <em>emitter, event, parameters</em>, just as the result of a <a href="../modules/sched.html#wait">wait</a></li>
       <li><code><em>attached</em></code>:  if true, the new task will run in attached more</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        task in the scheduler (see <a href="../modules/sched.html#taskd">taskd</a>).
    </ol>


</dd>
    <dt>
    <a name = "attach"></a>
    <strong>attach&nbsp;(taskd, taskd_child)</strong>
    </dt>
    <dd>
    Attach a task to another. 
 An attached task will be killed by the scheduler whenever
 the parent task is finished (returns, errors or is killed). Can be 
 invoked as taskd:attach(taskd_child).

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>taskd</em></code>:  The parent task</li>
       <li><code><em>taskd_child</em></code>:  The child (attached) task.</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        the modified taskd.
    </ol>


</dd>
    <dt>
    <a name = "set_as_attached"></a>
    <strong>set_as_attached&nbsp;(taskd)</strong>
    </dt>
    <dd>
    Set a task as attached to the creator task. 
 An attached task will be killed by the scheduler whenever
 the parent task (the task that created it) is finished (returns, errors or is killed). 
 Can be invoked as taskd:set<em>as</em>attached().

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>taskd</em></code>:  The child (attached) task.</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        the modified taskd.
    </ol>


</dd>
    <dt>
    <a name = "kill"></a>
    <strong>kill&nbsp;(taskd)</strong>
    </dt>
    <dd>
    Finishes a task. 
 The killed task will emit a signal <em>sched.EVENT_DIE, false, 'killed'</em>. Can be 
 invoked as taskd:kill().

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>taskd</em></code>:  task to terminate (see <a href="../modules/sched.html#taskd">taskd</a>).</li>
    </ul>




</dd>
    <dt>
    <a name = "signal"></a>
    <strong>signal&nbsp;(event, ...)</strong>
    </dt>
    <dd>
    Emit a signal. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>event</em></code>:  event of the signal. Can be of any type.</li>
       <li><code><em>...</em></code>:  further parameters to be sent with the signal.</li>
    </ul>




</dd>
    <dt>
    <a name = "new_waitd"></a>
    <strong>new_waitd&nbsp;(waitd_table)</strong>
    </dt>
    <dd>
    Create a Wait Descriptor. 
 Creates <a href="../modules/sched.html#waitd">waitd</a> object in the scheduler. Notice that buffering waitds
 start buffering as soon they are created.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>waitd_table</em></code>:  a table to convert into a wait descriptor.</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        a wait descriptor object.
    </ol>


</dd>
    <dt>
    <a name = "new_multiwaitd"></a>
    <strong>new_multiwaitd&nbsp;(...)</strong>
    </dt>
    <dd>
    Create a Multiwait Descriptor. 
 A Multiwait Descriptor is a <a href="../modules/sched.html#waitd">waitd</a> set up for for waiting on several other waitds 
 at the same time.
 The multiwaitd will provide all signals caught by any of the input waitds. The original 
 signal is available in the parameters. A multiwaitd has an additional attribute 
 compared to a plain waitd: a release() function. This function must be called when
 the multiwaitd is of no further use (for example, just before going out of scope).
 Notice that a multiwaitd is less efficient than normal waitd.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>...</em></code>:  waitds to listen on.</li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">local multiwaitd = sched.new_multiwaitd( waitd1, waitd2, waitd3 )
_,_,emitter, ev, par1, par2 = sched.wait(multiwaitd)</pre>
    </ul>

    <h3>Returns:</h3>
    <ol>
        a multiwaitd.
    </ol>


</dd>
    <dt>
    <a name = "wait"></a>
    <strong>wait&nbsp;(waitd)</strong>
    </dt>
    <dd>
    Wait for a signal. 
 Pauses the task until (one of) the specified signal(s) is available.
 If there are signals in the buffer, will return the first immediately.
 Otherwise will block the task until signal arrival, or a timeout.
 If provided a table as parameter, will use <a href="../modules/sched.html#new_waitd">new_waitd</a> to convert it
 to a wait desciptor.
 Can be invoked as waitd:wait().

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>waitd</em></code>:  a Wait Descriptor for the signal (see <a href="../modules/sched.html#waitd">waitd</a>)</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        On event returns <em>emitter, event, parameters</em>. On timeout
 returns <em>nil, 'timeout'</em>
    </ol>


</dd>
    <dt>
    <a name = "sleep"></a>
    <strong>sleep&nbsp;(timeout)</strong>
    </dt>
    <dd>
    Sleeps the task for t time units. 
 Time computed according to @{get_time}.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>timeout</em></code>:  time to sleep</li>
    </ul>




</dd>
    <dt>
    <a name = "yield"></a>
    <strong>yield&nbsp;()</strong>
    </dt>
    <dd>
    Yields the execution of a task, as in cooperative multitasking. 





</dd>
    <dt>
    <a name = "set_pause"></a>
    <strong>set_pause&nbsp;(taskd, pause)</strong>
    </dt>
    <dd>
    Pause a task. 
 A paused task won't be scheduled for execution. If paused while waiting for a signal, 
 won't respond to signals. Signals on unbuffered waitds will get lost. Task's buffered 
 waitds will still buffer events. Can be invoked as taskd:set_pause(pause)

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>taskd</em></code>:  Task to pause (see <a href="../modules/sched.html#taskd">taskd</a>).</li>
       <li><code><em>pause</em></code>:  mode, true to pause, false to unpause</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        the modified taskd on success or <em>nil, errormessage</em> on failure.
    </ol>


</dd>
    <dt>
    <a name = "idle"></a>
    <strong>idle&nbsp;(t)</strong>
    </dt>
    <dd>
    Idle function. 
 Function called by the scheduler when there is
 nothing else to do (e.g., all tasks are waiting for a signal).
 This function should idle up to t time units (notice that an empty
 function satisifies this, tough results in busy waits). Replace with
 whatever your app uses. LuaSocket's sleep works just fine.
 It is allowed to idle for less than t; the empty function will
 result in a busy wait. Defaults to execution of Linux's "sleep" command.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  time to idle</li>
    </ul>




</dd>
    <dt>
    <a name = "get_time"></a>
    <strong>get_time&nbsp;()</strong>
    </dt>
    <dd>
    Function used by the scheduler to get current time. 
 Replace with whatever your app uses. LuaSocket's gettime works just fine.
 Defaults to os.time.





</dd>
    <dt>
    <a name = "step"></a>
    <strong>step&nbsp;()</strong>
    </dt>
    <dd>
    Runs a single step of the scheduler. 



    <h3>Returns:</h3>
    <ol>
        the idle time available until more activity is expected; this
 means it will be 0 if there are active tasks.
    </ol>


</dd>
    <dt>
    <a name = "go"></a>
    <strong>go&nbsp;()</strong>
    </dt>
    <dd>
    Starts the scheduler. 
 Will run until there is no more activity, i.e. there's no active task,
 and none of the waiting tasks has a timeout set.





</dd>
</dl>
    <h2><a name="Tables"></a>Tables</h2>
    
    <dl class="function">
    <dt>
    <a name = "tasks"></a>
    <strong>tasks</strong>
    </dt>
    <dd>
    Tasks in scheduler. 
 Table holding <a href="../modules/sched.html#taskd">taskd</a> objects of the tasks in the scheduler. 


    <h3>Usage:</h3>
    <ul>
        <pre class="example">for taskd, _ in pairs (sched.tasks) do print(taskd) end</pre>
    </ul>



</dd>
</dl>
    <h2><a name="Fields"></a>Fields</h2>
    
    <dl class="function">
    <dt>
    <a name = "waitds"></a>
    <strong>waitds</strong>
    </dt>
    <dd>
    Wait descriptors in scheduler. 
 Table holding <a href="../modules/sched.html#waitd">waitd</a> objects used in the scheduler. Associates to each waitd
 a table with the <a href="../modules/sched.html#waitd">waitd</a>s of tasks that use it.


    <h3>Usage:</h3>
    <ul>
        <pre class="example">for waitd, _ in pairs (sched.waitds) do print(waitd) end 
end</pre>
    </ul>



</dd>
    <dt>
    <a name = "EVENT_DIE"></a>
    <strong>EVENT_DIE</strong>
    </dt>
    <dd>
    Task dying event. 
 This event will be emitted when a task dies. When the task dies a natural 
 death (finishes), the first parameter is true, followed by 
 the task returns. Otherwise, the first parameter is nil and the second 
 is 'killed' if the task was killed, or the error message if the task errore'd.


    <h3>Usage:</h3>
    <ul>
        <pre class="example">--prints each time a task dies
sched.sigrun({emitter='*', events={sched.EVENT_DIE}}, print)</pre>
    </ul>



</dd>
    <dt>
    <a name = "to_clean_up"></a>
    <strong>to_clean_up</strong>
    </dt>
    <dd>
    Control memory collection. 
 number of new insertions in waiting[event] before triggering clean_up.
 Defaults to 1000





</dd>
    <dt>
    <a name = "running_task"></a>
    <strong>running_task</strong>
    </dt>
    <dd>
    Currently running task. 
 the task descriptor from current task.





</dd>
    <dt>
    <a name = "debug"></a>
    <strong>debug</strong>
    </dt>
    <dd>
    Debugging module. 
 The debug module allows to have a better look at the workings of a Lumen
 application (see <a href="../modules/debug.html#">debug</a>).





</dd>
</dl>
    <h2><a name="Data_structures"></a>Data structures</h2>
     Main structures used.
    <dl class="function">
    <dt>
    <a name = "waitd"></a>
    <strong>waitd</strong>
    </dt>
    <dd>
    Wait descriptor. 
 Specifies a condition on which wait. Includes a signal description,
 a optional timeout specification and buffer configuration.
 A wait descriptor can be reused (for example, when waiting inside a
 loop) and shared amongst different tasks. If a wait descriptor changes
 while there is a task waiting, the behavior is unspecified. Notice that
 when sharing a wait descriptor between several tasks, the buffer is
 associated to the wait descriptor, and tasks will service buffered signals
 on first request basis.

    <h3>Fields:</h3>
    <ul>
       <li><code><em>emitter</em></code>:  optional, task originating the signal we wait for. If '*' or nil,
 means anyone. It also can be an array of  tasks, in which case any of 
 them is accepted as a source (see <a href="../modules/sched.html#taskd">taskd</a>).</li>
       <li><code><em>timeout</em></code>:  optional, time to wait. nil or negative waits for ever.</li>
       <li><code><em>buff_len</em></code>:  Maximum length of the buffer. A buffer allows for storing
 signals that arrived while the task is not blocked on the wait descriptor.
 Whenever there is an attempt to insert in a full buffer, the dropped
 flag is set. nil o 0 disables, negative means no length limit.</li>
       <li><code><em>buff_mode</em></code>:  Specifies how to behave when inserting in a full buffer.
 'drop first' means drop the oldest signals to make space. 'drop last'
 or nil will skip the insertion in a full buffer.</li>
       <li><code><em>dropped</em></code>:  the scheduler will set this to true when dropping events
 from the buffer. Can be reset by the user.</li>
       <li><code><em>events</em></code>:  optional, array with the events to wait. Can contain a '*', 
 or be '*' instead of a table, to mark interest in any event. If nil, will
 only return on timeout.</li>
    </ul>




</dd>
    <dt>
    <a name = "taskd"></a>
    <strong>taskd</strong>
    </dt>
    <dd>
    Task descriptor. 
 Handler of a task. Besides the following fields, provides methods for
 the sched functions that have a taskd as first parameter.

    <h3>Fields:</h3>
    <ul>
       <li><code><em>status</em></code>:  Status of the task, can be 'ready', 'paused' or 'dead'</li>
       <li><code><em>waitingfor</em></code>:  If the the task is waiting for a signal, this is the 
 Wait Descriptor (see <a href="../modules/sched.html#waitd">waitd</a>)</li>
       <li><code><em>waketime</em></code>:  The time at which to task will be forced to wake-up (due
 to a timeout on a wait)</li>
       <li><code><em>created_by</em></code>:  The task that started this one.</li>
       <li><code><em>attached</em></code>:  Table containing attached tasks.</li>
       <li><code><em>co</em></code>:  The coroutine of the task</li>
    </ul>




</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.2</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
